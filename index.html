<!DOCTYPE html>
  <html>
  <head>
    <title>Leap JavaScript API</title>
    <link rel="stylesheet" type="text/css" href="leap.css">
  </head>
  <body style="height:100%; display:table;">
    <h1>Leap JavaScript/WebSocket Sample</h1>
    <div id="connection">WebSocket not connected</div>
    <div id="main" style="width:100%; height:100%; margin:10px; display:table-row;">
      <p>JSON Frame data:</p>
      <input type="radio" name="visualization-type" value="tabular" checked="checked" />Tabular&nbsp;
      <input type="radio" name="visualization-type" value="3d" />3D&nbsp;
      <input type="checkbox" id="debug" checked="" />Debug
      <div id="output"></div>
      <div id="3d-container" style="width:100%; height:100%; display:table-row; background-color:#E8E8E8;"></div>
    </div>
  <script type="text/javascript" src="jquery-1.9.0.min.js"></script>
  <script type="text/javascript" src="leap.js"></script>
  <script type="text/javascript" src="handlebars-1.0.rc.1.js"></script>
  <script type="text/javascript" src="three.min.js"></script>
  <script id="gestures-template" type="text/x-handlebars-template">
    <div id="gestures">
      <p>Gestures</p>

      {{#each gestures}}
      <p>ID: {{this.id}}</p>
      <p>Type: {{this.type}}</p>
      <table>
        <tr>
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
        </tr>
        <tr>
          <td>Direction</td>
          <td>{{this.direction.[0]}}</td>
          <td>{{this.direction.[1]}}</td>
          <td>{{this.direction.[2]}}</td>
        </tr>
      {{/each}}
      </table>
    </div>
  </script>
  <script id="hands-template" type="text/x-handlebars-template">
    <div id="hands">
      <p># of hands: {{hands.length}}</p>

      {{#each hands}}
      <p>ID: {{this.id}}</p>
      <table>
        <tr>
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
        </tr>
        <tr>
          <td>Palm Position</tc>
          <td>{{this.palmPosition.[0]}}</td>
          <td>{{this.palmPosition.[1]}}</td>
          <td>{{this.palmPosition.[2]}}</td>
        </tr>
        <tr>
          <td>Direction</td>
          <td>{{this.direction.[0]}}</td>
          <td>{{this.direction.[1]}}</td>
          <td>{{this.direction.[2]}}</td>
        </tr>
        <tr>
          <td>Sphere Center</td>
          <td>{{this.sphereCenter.[0]}}</td>
          <td>{{this.sphereCenter.[1]}}</td>
          <td>{{this.sphereCenter.[2]}}</td>
        </tr>
        <tr>
          <td>Sphere Radius</td>
          <td colspan="3">{{this.sphereRaduis}}</td>
        </tr>
      {{/each}}
      </table>
    </div>
  </script>
  <script id="pointables-template" type="text/x-handlebars-template">
    <div id="pointables">
      <p># of pointables: {{pointables.length}}</p>

      {{#each pointables}}
      <p>ID: {{this.id}}</p>
      <p>Hand ID: {{this.handId}}</p>
      <p>Length: {{this.length}}</p>
      <p>Is a tool? {{tool}}</p>
      <table>
        <tr>
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
        </tr>
        <tr>
          <td>Direction</td>
          <td>{{this.direction.[0]}}</td>
          <td>{{this.direction.[1]}}</td>
          <td>{{this.direction.[2]}}</td>
        </tr>
        <tr>
          <td>Tip Position</tc>
          <td>{{this.tipPosition.[0]}}</td>
          <td>{{this.tipPosition.[1]}}</td>
          <td>{{this.tipPosition.[2]}}</td>
        </tr>
        <tr>
          <td>Tip Velocity</td>
          <td>{{this.tipVelocity.[0]}}</td>
          <td>{{this.tipVelocity.[1]}}</td>
          <td>{{this.tipVelocity.[2]}}</td>
        </tr>
      {{/each}}
      </table>
    </div>
  </script>
  <script>
    var ws, renderType;
    var handsTemplate, pointablesTemplate, gesturesTemplate;
    var renderer, camera, scene, spheres = new Array();

    // Support both the WebSocket and MozWebSocket objects
    if ((typeof(WebSocket) == 'undefined') &&
        (typeof(MozWebSocket) != 'undefined')) {
      WebSocket = MozWebSocket;
    }

    // Create the socket with event handlers
    $(document).ready(function () {
      renderType = $("#main input[name='visualization-type']").val();

      $("#main input[name='visualization-type']").on('change', function () {
        renderType = $(this).val();

        if (renderType === "3d") {
          $("#output").empty();
          render();
        }
      });

      $("#3d-container").hide();

      initTemplates();
      initThree();

      Leap.loop({enableGestures: true}, function (frame, done) {
        // console.log(renderType);
        switch (renderType) {
          case "tabular":
            renderTabularData(frame);
            break;

          case "3d":
            render3D(frame);
            break;
        }

        done();
      })
    });

    function initTemplates () {
      var handsSource = $("#hands-template").html();
      handsTemplate = Handlebars.compile(handsSource);
      var pointablesSource = $("#pointables-template").html();
      pointablesTemplate = Handlebars.compile(pointablesSource);
      var gesturesSource = $("#gestures-template").html();
      gesturesTemplate = Handlebars.compile(gesturesSource);
    };

    function initThree () {
      // set the scene size
      var WIDTH = $("#3d-container").width(),
        HEIGHT = $("#3d-container").height();

      // set some camera attributes
      var VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000;

      // create a WebGL renderer, camera
      // and a scene
      camera =
        new THREE.PerspectiveCamera(
          VIEW_ANGLE,
          ASPECT,
          NEAR,
          FAR);

      // the camera starts at 0,0,0
      // so pull it back
      camera.position.z = 500;

      scene = new THREE.Scene();

      // add the camera to the scene
      scene.add(camera);

      createSpheres(scene);

      // create a point light
      var pointLight =
        new THREE.PointLight(0xFFFFFF);

      // set its position
      pointLight.position.x = 10;
      pointLight.position.y = 50;
      pointLight.position.z = 130;

      // add to the scene
      scene.add(pointLight);

      // start the renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(WIDTH, HEIGHT);

      // attach the render-supplied DOM element
      $('#3d-container').append(renderer.domElement);
    };

    function renderTabularData (leapData) {
      var handsHtml = handsTemplate({hands: leapData.hands});
      var gesturesHtml = gesturesTemplate({gestures: leapData.gestures});
      var pointablesHtml = pointablesTemplate({pointables: leapData.pointables});
      $("#output").empty();
      $("#output").append(handsHtml).append(gesturesHtml).append(pointablesHtml);
      // var str = JSON.stringify(leapData);
      // console.log(leapData);
      // $("#output").html('<pre>' + str + '</pre>');
    };

    function createSpheres (scene) {
      // set up the sphere vars
      var radius = 10,
          segments = 16,
          rings = 16;

      // create the sphere's material
      var sphereMaterial =
        new THREE.MeshLambertMaterial(
          {
            color: 0xCC0000
          });

      for (var i = 0; i < 5; i++) {
        // create a new mesh with
        // sphere geometry - we will cover
        // the sphereMaterial next!
        var sphere = new THREE.Mesh(
          new THREE.SphereGeometry(
            radius,
            segments,
            rings),
          sphereMaterial);

        // add the sphere to the scene
        scene.add(sphere);
        spheres.push(sphere);
      }
    };

    function render3D (leapData) {
      if (leapData.pointables.length == 0) {
        return;
      }

      $("#3d-container").show();

      var width = $("#3d-container").width();
      var height = $("#3d-container").height();

      for (var i = 0; i < leapData.pointables.length; i++) {
        spheres[i].position.x = leapData.pointables[i].tipPosition[0];
        spheres[i].position.y = leapData.pointables[i].tipPosition[1] - 100;
        spheres[i].position.z = leapData.pointables[i].tipPosition[2];
      };

      // console.log("Sphere - x:" + sphere.position.x + " y:" + sphere.position.y + " z:" + sphere.position.z);
    };

    function render() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }
    </script>
  </body>
</html>

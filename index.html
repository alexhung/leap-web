<!DOCTYPE html>
  <html>
  <head>
    <title>Leap JavaScript API</title>
  </head>
  <body>
    <h1>Leap JavaScript/WebSocket Sample</h1>
    <div id="connection">WebSocket not connected</div>
    <div id="main">
      <p>JSON Frame data:</p>
      <input type="radio" name="visualization-type" value="tabular" checked="checked" />Tabular&nbsp;
      <input type="radio" name="visualization-type" value="3d" />3D&nbsp;
      <input type="checkbox" id="debug" checked="" />Debug
      <div id="output">
      </div>
      <div id="3dContainer" style="width: 800px; height: 600px;">
      </div>
    </div>
  <script type="text/javascript" src="jquery-1.9.0.min.js"></script>
  <script type="text/javascript" src="handlebars-1.0.rc.1.js"></script>
  <script type="text/javascript" src="three.min.js"></script>
  <script id="hands-template" type="text/x-handlebars-template">
    <div id="hands">
      <p># of hands: {{hands.length}}</p>

      {{#each hands}}
      <p>ID: {{this.id}}</p>
      <table>
        <tr>
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
        </tr>
        <tr>
          <td>Palm Position</tc>
          <td>{{this.palmPosition.[0]}}</td>
          <td>{{this.palmPosition.[1]}}</td>
          <td>{{this.palmPosition.[2]}}</td>
        </tr>
        <tr>
          <td>Direction</td>
          <td>{{this.direction.[0]}}</td>
          <td>{{this.direction.[1]}}</td>
          <td>{{this.direction.[2]}}</td>
        </tr>
        <tr>
          <td>Sphere Center</td>
          <td>{{this.sphereCenter.[0]}}</td>
          <td>{{this.sphereCenter.[1]}}</td>
          <td>{{this.sphereCenter.[2]}}</td>
        </tr>
        <tr>
          <td>Sphere Radius</td>
          <td colspan="3">{{this.sphereRaduis}}</td>
        </tr>
      {{/each}}
      </table>
    </div>
  </script>
  <script id="pointables-template" type="text/x-handlebars-template">
    <div id="pointables">
      <p># of pointables: {{pointables.length}}</p>

      {{#each pointables}}
      <p>ID: {{this.id}}</p>
      <p>Hand ID: {{this.handId}}</p>
      <p>Length: {{this.length}}</p>
      <p>Is a tool? {{tool}}</p>
      <table>
        <tr>
          <th></th>
          <th>X</th>
          <th>Y</th>
          <th>Z</th>
        </tr>
        <tr>
          <td>Direction</td>
          <td>{{this.direction.[0]}}</td>
          <td>{{this.direction.[1]}}</td>
          <td>{{this.direction.[2]}}</td>
        </tr>
        <tr>
          <td>Tip Position</tc>
          <td>{{this.tipPosition.[0]}}</td>
          <td>{{this.tipPosition.[1]}}</td>
          <td>{{this.tipPosition.[2]}}</td>
        </tr>
        <tr>
          <td>Tip Velocity</td>
          <td>{{this.tipVelocity.[0]}}</td>
          <td>{{this.tipVelocity.[1]}}</td>
          <td>{{this.tipVelocity.[2]}}</td>
        </tr>
      {{/each}}
      </table>
    </div>
  </script>
  <script>
    var ws, renderType;
    var handsTemplate, pointablesTemplate;
    var renderer, camera, scene, spheres = new Array();

    // Support both the WebSocket and MozWebSocket objects
    if ((typeof(WebSocket) == 'undefined') &&
        (typeof(MozWebSocket) != 'undefined')) {
      WebSocket = MozWebSocket;
    }

    // Create the socket with event handlers
    $(document).ready(function () {
      renderType = $("#main input[name='visualization-type']").val();
      $("#main input[name='visualization-type']").on('change', function () {
        renderType = $(this).val();

        if (renderType === "3d") {
          $("#output").empty();
          render();
        }
      });

      initTemplates();
      initThree();
      initWebSocket();
    });

    function initTemplates () {
      var handsSource = $("#hands-template").html();
      handsTemplate = Handlebars.compile(handsSource);
      var pointablesSource = $("#pointables-template").html();
      pointablesTemplate = Handlebars.compile(pointablesSource);
    };

    function initWebSocket () {
      //Create and open the socket
      ws = new WebSocket("ws://localhost:6437/");

      // On successful connection
      ws.onopen = function(event) {
        $("#connection").text("WebSocket connection open!");
      };

      // On message received
      ws.onmessage = function(event) {
        var obj = JSON.parse(event.data);

        // console.log(renderType);
        switch (renderType) {
          case "tabular":
            renderTabularData(obj);
          break;

          case "3d":
            render3D(obj);
          break;
        }
      };

      // On socket close
      ws.onclose = function(event) {
        ws = null;
        $("#connection").text("WebSocket connection closed");
      }

      //On socket error
      ws.onerror = function(event) {
        alert("Received error");
      };
    };

    function initThree () {
      // set the scene size
      var WIDTH = $("#3dContainer").width(),
        HEIGHT = $("#3dContainer").height();

      // set some camera attributes
      var VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 1,
        FAR = 10000;

      // create a WebGL renderer, camera
      // and a scene
      camera =
        new THREE.PerspectiveCamera(
          VIEW_ANGLE,
          ASPECT,
          NEAR,
          FAR);

      // the camera starts at 0,0,0
      // so pull it back
      camera.position.z = 500;

      scene = new THREE.Scene();

      // add the camera to the scene
      scene.add(camera);

      createSpheres(scene);

      // start the renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(WIDTH, HEIGHT);

      // get the DOM element to attach to
      // - assume we've got jQuery to hand
      var $container = $('#3dContainer');

      // attach the render-supplied DOM element
      $container.append(renderer.domElement);
    };

    function renderTabularData (leapData) {
      var handsHtml = handsTemplate({hands: leapData.hands});
      var pointablesHtml = pointablesTemplate({pointables: leapData.pointables});
      $("#output").empty();
      $("#output").append(handsHtml).append(pointablesHtml);
      // var str = JSON.stringify(leapData, undefined, 2);
      // $("#output").html('<pre>' + str + '</pre>');
    };

    function createSpheres (scene) {
      // set up the sphere vars
      var radius = 10,
          segments = 16,
          rings = 16;

      // create the sphere's material
      var sphereMaterial =
        new THREE.MeshLambertMaterial(
          {
            color: 0xCC0000
          });

      for (var i = 0; i < 5; i++) {
        // create a new mesh with
        // sphere geometry - we will cover
        // the sphereMaterial next!
        var sphere = new THREE.Mesh(
          new THREE.SphereGeometry(
            radius,
            segments,
            rings),
          sphereMaterial);

        // add the sphere to the scene
        scene.add(sphere);
        spheres.push(sphere);
      }
    };

    function render3D (leapData) {
      if (leapData.pointables.length == 0) {
        return;
      }

      var width = $("#3dContainer").width();
      var height = $("#3dContainer").height();

      for (var i = 0; i < leapData.pointables.length; i++) {
        spheres[i].position.x = leapData.pointables[i].tipPosition[0];
        spheres[i].position.y = leapData.pointables[i].tipPosition[1] - 100;
        spheres[i].position.z = leapData.pointables[i].tipPosition[2];
      };

      // console.log("Sphere - x:" + sphere.position.x + " y:" + sphere.position.y + " z:" + sphere.position.z);
    };

    function render3DOld (leapData) {
      for (var i = scene.children.length - 1; i >= 0; i--) {
        if (scene.children[i] !== camera) {
          scene.remove(scene.children[i]);
        }
      }

      // set up the sphere vars
      var radius = 50,
          segments = 16,
          rings = 16;

      // create the sphere's material
      var sphereMaterial =
        new THREE.MeshLambertMaterial(
          {
            color: 0xCC0000
          });

      var width = $("#3dContainer").width();

      for (var i = 0; i < leapData.pointables.length; i++) {
        // create a new mesh with
        // sphere geometry - we will cover
        // the sphereMaterial next!
        sphere = new THREE.Mesh(
          new THREE.SphereGeometry(
            radius,
            segments,
            rings),
          sphereMaterial);

        sphere.position.x = leapData.pointables[i].tipPosition[0] + (width / 2);
        sphere.position.y = leapData.pointables[i].tipPosition[1] * -1;
        sphere.position.z = leapData.pointables[i].tipPosition[2];

        console.log("Sphere - x:" + sphere.position.x + " y:" + sphere.position.y + " z:" + sphere.position.z);

        // add the sphere to the scene
        scene.add(sphere);
      };
    };

    function render() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }
    </script>
  </body>
</html>
